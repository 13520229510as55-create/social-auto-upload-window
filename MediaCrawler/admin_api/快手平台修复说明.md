# 快手平台修复说明文档

本文档记录了快手平台在 MediaCrawler 管理后台中的各种修复和配置问题，以及相应的解决方案。用于避免后续重复出现相同问题。

## 目录

1. [URL配置修复](#1-url配置修复)
2. [Cookie处理统一](#2-cookie处理统一)
3. [登录流程修复](#3-登录流程修复)
4. [数据列表显示](#4-数据列表显示)
5. [模块导入问题](#5-模块导入问题)
6. [常见问题排查](#6-常见问题排查)

---

## 1. URL配置修复

### 问题描述
快手爬虫初始访问的URL需要添加特定参数以符合平台要求。

### 修复内容
**文件**: `media_platform/kuaishou/core.py`

**修改前**:
```python
await self.context_page.goto(f"{self.index_url}?isHome=1")
```

**修改后**:
```python
await self.context_page.goto(f"{self.index_url}/?isHome=1&source=NewReco")
```

### 修改位置
1. **初始页面访问** (`core.py:96`):
   ```python
   self.context_page = await self.browser_context.new_page()
   await self.context_page.goto(f"{self.index_url}/?isHome=1&source=NewReco")
   ```

2. **Cookie刷新时的页面访问** (`core.py:302`):
   ```python
   time.sleep(20)
   await self.context_page.goto(f"{self.index_url}/?isHome=1&source=NewReco")
   await self.ks_client.update_cookies(browser_context=self.browser_context)
   ```

### 注意事项
- URL必须包含 `/` 路径分隔符：`https://www.kuaishou.com/?isHome=1&source=NewReco`
- 参数 `source=NewReco` 是必需的，用于标识来源
- API请求地址保持不变：`https://www.kuaishou.com/graphql`

---

## 2. Cookie处理统一

### 问题描述
确保快手的cookie处理逻辑与小红书保持一致，包括cookie保存路径、登录状态检查等。

### 修复内容

#### 2.1 Cookie保存路径
**文件**: `admin_api/login_service.py`

快手cookie保存在项目根目录的 `cookies/` 目录下，文件名格式：`ks_cookies.json`

```python
def _get_cookie_file_path(self, platform: str) -> Path:
    """获取cookie文件路径"""
    platform_map = {
        "xhs": "xhs",
        "ks": "ks",  # 快手
        # ... 其他平台
    }
    cookie_filename = f"{platform_map.get(platform, platform)}_cookies.json"
    cookie_file_path = project_root / "cookies" / cookie_filename
    return cookie_file_path
```

#### 2.2 登录状态检查
**文件**: `admin_api/login_service.py`

快手登录状态通过 `passToken` cookie 来判断（不是 `kuaishou.com_st`）：

```python
def _check_platform_login_status(self, platform: str, cookie_dict: Dict[str, str], page: Page) -> bool:
    """检查平台登录状态"""
    if platform == "ks":
        # 快手使用passToken作为登录凭证
        passToken = cookie_dict.get("passToken")
        return bool(passToken)
    # ... 其他平台
```

#### 2.3 Cookie获取优化
**文件**: `admin_api/login_service.py`

在 `check_login_status` 方法中，对于快手平台，需要获取所有cookie，如果找不到 `passToken`，再尝试获取特定域名的cookie并合并：

```python
if platform == "ks":
    # 先尝试获取所有cookie
    cookies = await context.cookies()
    # 如果没有找到passToken，再尝试指定域名
    cookie_dict_temp = {c["name"]: c["value"] for c in cookies}
    if "passToken" not in cookie_dict_temp:
        cookies_specific = await context.cookies("https://www.kuaishou.com")
        # 合并cookie
        cookies_dict = {c["name"]: c for c in cookies}
        for c in cookies_specific:
            cookies_dict[c["name"]] = c
        cookies = list(cookies_dict.values())
```

---

## 3. 登录流程修复

### 3.1 二维码登录按钮点击

#### 问题描述
快手登录页面需要手动点击"立即登录"按钮才会弹出二维码，二维码不会自动显示。

#### 修复内容
**文件**: `media_platform/kuaishou/login.py` 和 `admin_api/login_service.py`

**登录按钮选择器**:
```python
login_button_selector = "xpath=//span[contains(@class,'btn-words') and contains(.,'登录')]"
```

**点击逻辑**:
```python
# 等待登录按钮出现
await self.context_page.wait_for_selector(login_button_selector, timeout=10000)
login_button_ele = self.context_page.locator(login_button_selector)
await login_button_ele.click()
await asyncio.sleep(3)  # 等待二维码出现
```

#### 备用选择器
如果主选择器失败，可以尝试以下备用选择器：
- `xpath=//span[contains(@class,'btn-words')]`
- `xpath=//span[contains(.,'登录')]`
- `css=.btn-words`

### 3.2 二维码选择器

**二维码图片选择器**:
```python
qrcode_img_selector = "//div[@class='qrcode-img']//img"
```

### 3.3 浏览器选择

#### 问题描述
需要使用用户本地安装的Chrome浏览器，而不是Playwright自带的Chromium。

#### 修复内容
**文件**: `admin_api/login_service.py`

```python
# 检测系统Chrome路径
import platform as platform_module
system = platform_module.system()
if system == "Darwin":  # macOS
    chrome_paths = [
        "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
        "/Applications/Chromium.app/Contents/MacOS/Chromium",
    ]
elif system == "Windows":
    chrome_paths = [
        r"C:\Program Files\Google\Chrome\Application\chrome.exe",
        r"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe",
    ]
else:  # Linux
    chrome_paths = [
        "/usr/bin/google-chrome",
        "/usr/bin/chromium-browser",
        "/usr/bin/chromium",
    ]

# 尝试使用系统Chrome
browser = None
for chrome_path in chrome_paths:
    if os.path.exists(chrome_path):
        try:
            browser = await playwright.chromium.launch(
                executable_path=chrome_path,
                headless=False,
                args=["--disable-blink-features=AutomationControlled"]
            )
            break
        except Exception as e:
            continue

# 如果系统Chrome不可用，尝试channel方式
if browser is None:
    try:
        browser = await playwright.chromium.launch(
            channel="chrome",
            headless=False,
            args=["--disable-blink-features=AutomationControlled"]
        )
    except Exception:
        # 最后使用默认Chromium
        browser = await playwright.chromium.launch(headless=False)
```

### 3.4 浏览器资源清理

#### 问题描述
登录成功后，浏览器没有正确关闭，导致资源泄漏。

#### 修复内容
**文件**: `admin_api/login_service.py`

```python
async def _cleanup_session(self, qrcode_id: str):
    """清理会话资源"""
    if qrcode_id not in self.sessions:
        return
    
    session = self.sessions[qrcode_id]
    try:
        # 按顺序关闭：page -> context -> browser -> playwright
        if "page" in session and session["page"]:
            try:
                if not session["page"].is_closed():
                    await session["page"].close()
            except Exception as e:
                print(f"[LoginService._cleanup_session] 关闭page时出错: {e}")
        
        if "context" in session and session["context"]:
            try:
                if session["context"].pages:
                    for p in session["context"].pages:
                        if not p.is_closed():
                            await p.close()
                await session["context"].close()
            except Exception as e:
                print(f"[LoginService._cleanup_session] 关闭context时出错: {e}")
        
        if "browser" in session and session["browser"]:
            try:
                if session["browser"].is_connected():
                    await session["browser"].close()
            except Exception as e:
                print(f"[LoginService._cleanup_session] 关闭browser时出错: {e}")
        
        if "playwright" in session and session["playwright"]:
            try:
                await session["playwright"].stop()
            except Exception as e:
                print(f"[LoginService._cleanup_session] 停止Playwright时出错: {e}")
    finally:
        del self.sessions[qrcode_id]

async def _delayed_cleanup(self, qrcode_id: str, delay: float = 2.0):
    """延迟清理，给前端时间处理响应"""
    await asyncio.sleep(delay)
    await self._cleanup_session(qrcode_id)
```

**清理时机**:
- 登录成功后，延迟2秒清理（给前端时间关闭二维码显示）
- 二维码过期后立即清理
- 前端取消登录时立即清理

### 3.5 前端轮询修复

#### 问题描述
前端登录状态轮询不工作，导致扫码后状态不更新。

#### 修复内容
**文件**: `admin_api/frontend/src/components/QRCodeLogin.jsx`

使用 `useCallback` 避免闭包问题，并立即执行一次检查：

```javascript
const checkLoginStatus = useCallback(async () => {
  if (!qrcodeId) {
    return
  }
  
  try {
    const data = await api.get(`/login/status/${qrcodeId}`)
    setStatus(data.status)
    
    if (data.status === 'success') {
      message.success('登录成功！')
      setVisible(false)
      if (onSuccess) onSuccess()
    } else if (data.status === 'expired') {
      message.warning('二维码已过期，请重新获取')
      setVisible(false)
    }
  } catch (error) {
    console.error('[QRCodeLogin] 检查登录状态失败:', error)
  }
}, [qrcodeId, onSuccess])

useEffect(() => {
  if (visible && qrcodeId) {
    // 立即检查一次
    checkLoginStatus()
    // 然后每2秒检查一次
    const interval = setInterval(() => {
      checkLoginStatus()
    }, 2000)
    
    return () => {
      clearInterval(interval)
    }
  }
}, [visible, qrcodeId, checkLoginStatus])  // 注意：checkLoginStatus必须在依赖数组中
```

---

## 4. 数据列表显示

### 4.1 字段映射

#### 问题描述
快手数据结构和字段名与小红书不同，需要在后端进行字段映射。

#### 修复内容
**文件**: `admin_api/main.py` - `get_crawled_data` 函数

**快手字段映射**:
```python
if platform == "ks":
    formatted_item = {
        "id": item.get("video_id", ""),  # 快手使用video_id
        "title": item.get("title", ""),
        "author": item.get("nickname", ""),
        "publish_time": publish_time,
        "liked_count": item.get("liked_count", "0"),
        "comment_count": item.get("comment_count", "0"),
        "collected_count": item.get("viewd_count", "0"),  # 快手用viewd_count作为收藏数
        "share_count": "0",  # 快手数据中没有直接的分享数
        "desc": item.get("desc", ""),
        "note_url": item.get("video_url", ""),  # 快手使用video_url
        "type": "video" if item.get("video_type") == "video" else "normal",
        "source_keyword": item.get("source_keyword", ""),
    }
```

### 4.2 评论字段映射

**文件**: `admin_api/main.py` - `get_note_comments` 函数

**快手评论字段映射**:
```python
if platform == "ks":
    formatted_comment = {
        "id": comment.get("comment_id", ""),
        "author": comment.get("nickname", ""),
        "avatar": comment.get("headurl", ""),  # 快手使用headurl
        "content": comment.get("content", ""),
        "liked_count": str(comment.get("liked_count", 0)),
        "create_time": create_time,
        "user_id": comment.get("authorId", ""),  # 快手使用authorId
        "sub_comment_count": comment.get("subCommentCount", 0),  # 快手使用subCommentCount
    }
```

### 4.3 数据目录映射

**文件**: `admin_api/main.py`

**平台目录映射**:
```python
# API中使用 'ks'，但文件系统中是 'kuaishou'
platform_dir = "kuaishou" if platform == "ks" else platform
data_dir = project_root / "data" / platform_dir / "json"
```

### 4.4 评论查询参数

**文件**: `admin_api/main.py` - `get_note_comments` 函数

使用通用的 `item_id` 参数，内部根据平台映射：
- 小红书：`item_id` -> `note_id`
- 快手：`item_id` -> `video_id`

```python
@app.get("/api/data/{platform}/comments/{item_id}")
async def get_note_comments(platform: str, item_id: str):
    # ...
    if platform == "ks":
        # 快手使用video_id
        target_id = item_id
    else:
        # 小红书使用note_id
        target_id = item_id
    # ...
```

---

## 5. 模块导入问题

### 5.1 MediaCrawler模块导入

#### 问题描述
后端服务启动时，MediaCrawler主模块导入失败，导致CrawlerFactory为None。

#### 修复内容
**文件**: `admin_api/main.py`

**添加详细的导入日志**:
```python
try:
    os.chdir(str(project_root))
    spec.loader.exec_module(mediacrawler_main)
    CrawlerFactory = mediacrawler_main.CrawlerFactory
    print(f"[main] ✓ MediaCrawler主模块导入成功，CrawlerFactory: {CrawlerFactory}")
except Exception as e:
    print(f"警告: MediaCrawler主模块导入失败: {e}")
    import traceback
    traceback.print_exc()
    CrawlerFactory = None
```

**依赖检查**:
确保以下依赖已安装：
- `opencv-python` (cv2) - 用于图片处理和滑块验证
- `sqlalchemy`, `pandas`, `redis`, `aiomysql`, `aiofiles`
- `jieba`, `qrcode`, `matplotlib`, `wordcloud`
- `motor`, `pyexecjs`, `parsel`, `aiosqlite`
- `pyhumps`, `lxml`, `cssselect`, `w3lib`
- `et-xmlfile`, `jmespath`, `openpyxl`

**安装依赖**:
```bash
cd /Users/a58/MediaCrawler
pip install -r requirements.txt
```

### 5.2 登录服务依赖检查

**文件**: `admin_api/login_service.py`

登录服务在导入时会检查依赖是否可用：

```python
try:
    import config
    from tools import crawler_util, utils
    from tools.cdp_browser import CDPBrowserManager
    import cv2  # opencv-python
    DEPENDENCIES_AVAILABLE = True
except ImportError as e:
    DEPENDENCIES_AVAILABLE = False
    print(f"[login_service] 导入失败的模块: {e}")
```

---

## 6. 常见问题排查

### 6.1 二维码登录失败

**症状**: 点击登录按钮后，二维码不显示或显示失败。

**排查步骤**:
1. 检查登录按钮选择器是否正确
2. 确认浏览器使用的是系统Chrome（不是Chromium）
3. 检查是否有JavaScript错误阻止二维码显示
4. 查看后端日志中的错误信息

**解决方案**:
- 更新登录按钮选择器
- 使用 `executable_path` 或 `channel="chrome"` 指定系统Chrome
- 增加等待时间：`await asyncio.sleep(3)` 等待二维码出现

### 6.2 Cookie未保存

**症状**: 登录成功后，Cookie没有保存到文件。

**排查步骤**:
1. 检查cookie文件路径是否正确
2. 确认 `passToken` cookie是否存在
3. 查看后端日志中的cookie保存信息

**解决方案**:
- 确认cookie文件路径：`project_root/cookies/ks_cookies.json`
- 检查cookie获取逻辑，确保获取所有cookie并合并
- 查看日志确认cookie保存成功

### 6.3 爬取任务失败：CrawlerFactory未初始化

**症状**: 启动爬取任务时，提示"CrawlerFactory未初始化，MediaCrawler模块导入失败"。

**排查步骤**:
1. 检查后端启动日志，查看MediaCrawler模块导入状态
2. 确认所有依赖是否已安装
3. 检查Python环境是否正确

**解决方案**:
```bash
# 1. 检查依赖
cd /Users/a58/MediaCrawler
pip install -r requirements.txt

# 2. 检查导入
python3 -c "from main import CrawlerFactory; print('导入成功')"

# 3. 重启后端服务
cd admin_api
lsof -ti:8000 | xargs kill -9
python3 main.py
```

### 6.4 数据列表为空

**症状**: 数据列表页面显示为空，但确认有数据文件。

**排查步骤**:
1. 检查数据文件路径：`data/kuaishou/json/`
2. 确认文件命名格式：`*contents*.json`, `*comments*.json`
3. 查看后端日志中的文件读取错误

**解决方案**:
- 确认平台目录映射：API中的 `ks` 对应文件系统的 `kuaishou`
- 检查JSON文件格式是否正确
- 查看后端日志中的错误信息

### 6.5 浏览器不关闭

**症状**: 登录成功后，浏览器窗口没有关闭。

**排查步骤**:
1. 检查 `_cleanup_session` 方法是否被调用
2. 确认清理逻辑是否正确执行
3. 查看是否有异常阻止清理

**解决方案**:
- 确保在登录成功后调用 `_delayed_cleanup`
- 检查资源关闭顺序：page -> context -> browser -> playwright
- 添加异常处理，确保即使出错也能继续清理

---

## 7. 相关文件清单

### 核心文件
- `media_platform/kuaishou/core.py` - 快手爬虫核心逻辑
- `media_platform/kuaishou/login.py` - 快手登录逻辑
- `media_platform/kuaishou/client.py` - 快手API客户端
- `admin_api/login_service.py` - 登录服务（通用）
- `admin_api/main.py` - 后端API主文件

### 前端文件
- `admin_api/frontend/src/components/QRCodeLogin.jsx` - 二维码登录组件
- `admin_api/frontend/src/pages/Data.jsx` - 数据列表页面

### 配置文件
- `cookies/ks_cookies.json` - 快手Cookie保存文件
- `data/kuaishou/json/` - 快手爬取数据目录

---

## 8. 测试检查清单

在部署或修复快手相关功能后，请按以下清单进行测试：

- [ ] 二维码登录：能够正常显示二维码并完成登录
- [ ] Cookie保存：登录后Cookie正确保存到文件
- [ ] Cookie复用：使用已保存的Cookie可以跳过登录
- [ ] 爬取任务：能够正常启动和完成爬取任务
- [ ] 数据列表：爬取的数据能够正确显示在数据列表中
- [ ] 评论显示：能够正确显示评论数据
- [ ] 浏览器清理：登录成功后浏览器正确关闭
- [ ] 前端轮询：前端能够正确轮询登录状态

---

## 9. 版本记录

- **2025-12-21**: 初始版本，记录所有快手相关修复
  - URL配置修复
  - Cookie处理统一
  - 登录流程修复
  - 数据列表显示修复
  - 模块导入问题修复

---

## 10. 参考链接

- [MediaCrawler项目主页](https://github.com/NanmiCoder/MediaCrawler)
- [快手平台文档](https://www.kuaishou.com/)
- [Playwright文档](https://playwright.dev/python/)

---

**最后更新**: 2025-12-21  
**维护者**: MediaCrawler开发团队




